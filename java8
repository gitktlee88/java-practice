<> List.of vs Arrays.asList

1, List.of can be best used when data set is less and unchanged, while 
   Arrays.asList can be used best in case of large and dynamic data set.

2, List.of take very less overhead space because it has field-based implementation and consume less heap space, 
   both in terms of fixed overhead and on a per-element basis. 
   while Arrays.asList take more overhead space because while initialization it creates more objects in heap.

3, Collection returned by List.of is immutable and hence thread-safe while 
   Collection returned by Arrays.asList is mutable and not thread safe. 
   (Immutable collection instances generally consume much less memory than their mutable counterparts.)

4, List.of doesn't allow null elements while Arrays.asList allows null elements.

<> Method references :: are awesome is that:

Method references are expressions which have the same treatment as lambda expressions (...), 
but instead of providing a method body, they refer an existing method by name.

Ex, instead of writing the lambda body
Function<Double, Double> square = (Double x) -> x * x;

You can simply do like
Function<Double, Double> square = Hey::square;

At runtime, these two square methods behave exactly the same as each other. 
The bytecode may or may not be the same 
(though, for the above case, the same bytecode is generated; compile the above and check with javap -c).
